---
title: 你不知道的javascript学习笔记 - 2.词法作用域
tags:
  - javascript
categories:
  - 前端
date: 2017-11-01 11:56:32
---

## 什么是词法作用域

今天来看一下词法作用域，之前说过编译器第一个阶段就是分词/词法解析，而在这个阶段产生的作用域就是词法作用域，词法作用域是代码位置的体现，他的作用域和代码位置相关。

来看下面的代码:

``` javascript
function foo(a){
    var b = a+1;

    function bar(c){
        console.log(a,b,c);
    }

    bar(b*3)
}

foo(2);
```

来看一下上面的代码，一共有三层嵌套的作用域：

1.  最外层作用域是全局作用域，foo函数在这个作用域中声明
2.  第二层是foo内部的函数作用域里面有三个标识符:a,b,c
3.  最里层是bar所创建的作用域，其中只有一个标识符:c

<!--more-->

三层作用域是嵌套的，形成了作用域链，而这里决定作用域关系的就是函数定义的位置。

像上一节说的，在查询标识符时，会寻着里层作用域依次向外层作用域进行查找，会在找到第一个匹配的标识符停止。所以多级嵌套的作用域可以定于同名的标识符，内部标识符会对外部标识符进行屏蔽。

``` javascript
function foo(a){
    var b = a+1;   
    function bar(){
        var a = 2;
        console.log(a+1);
    }
}

foo(1);
```

结果会打印`3`，因为它在`bar`函数内部找到了对应的标识符，不会向外部寻找。

一些时候需要访问同名的全局变量时，可以使用`window.a`的方法直接访问，这样可以访问那些被屏蔽的全局变量。

## 欺骗词法-作用域恶魔

有的时候作用域中有一些恶魔的存在，这些是一般现在不希望被使用的方法，他的存在会破坏原本的作用域，并且造成其他例如的问题。

#### eval

javascript中的`eval`函数可以接受一个参数，并将其相当于书写与这个位置的代码。

``` javascript
function foo(str,a){
    eval(str);
    console.log(a,b);//1,3
}

foo("var b = 3;",1);
```

上面的代码最终打印出了`1,3`，他对已经存在的`foo`的词法作用域进行了修改，添加了变量`b`，实现了运行时对词法作用域的修改。

值得注意的是在严格模式下`use strict` 是无法修改词法作用域的。

同时和他类似还有一些其他函数也可以对词法作用域进行修改，这同样是不提倡的:

* setTimeout(...)，第一个参数可以传入代码字符串
* setInterval(...)，第一个参数可以传入字符串
* new Function(...)，最后一个参数可以传入代码字符串

#### with

javascript中的`with`函数一般被当作重复引入同一个对象中多个属性的快捷方式，这可以不需要重复引入对象本身。

``` javascript
var obj ={
    a:1,
    b:2,
    c:3
}

obj.a = 2;
obj.b = 3;
obj.c = 4;

with(obj){
    a = 3;
    b = 4;
    c = 5;
    }
```
这样看的确可以便捷的访问属性，再看看下面的代码:

``` javascript
 function foo(obj){
     with(obj){
         a = 2;
     }
 }
    
 var o1 = {
     a:3
 };

 var o2 = {
     b:3
 }

 foo(o1);
 console.log(o1.a); // 2

 foo(o2);
 console.log(o2.a); // undefined

 console.log(a);    //2
```

先看看上面的结果，我们的初衷是给`o1.a`修改为`2`,给`o2.a`赋值`2`,但很抱歉的是，他没有完全按照我们的想法来，因为`with`函数会形成一个新的作用域，作用内部进行了`LSH`查询，当他没有查到标识符时，他沿着作用域链向上请求，一直到根作用域都没有找到，就在根作用域创建了`a`对象，发生了内存泄漏。

这些都是很容易发生的问题，也是我们杜绝使用`eval`的一部分原因。

## 对性能的影响

如果说为什么应该杜绝使用`eval`，`with`这些函数函数，隐式的修改和创建作用域是一个原因，另一部分原因就是他们对性能的影响。

在javascript引擎的编译阶段，会进行数项性能优化，这些优化一些依赖于根据对代码的词法进行静态分析，预先确定了所有变量和函数的定义位置，所以可以在执行过程中快速找到标识符。

但是如果使用了`eval`或`with`，那么它只能判断之前假设的对标识符位置的判断无效的，因为你无法在词法分析阶段得知`eval`会接收什么，也无法知道传递给`with`用来创建新词法作用域的对象的内容是什么。

最悲观的情况是如果出现了`eval`或`with`，所有的优化可能都是无效的。这样，如果代码中大量使用`eval`和`with`那么运行起来一定会非常慢。





